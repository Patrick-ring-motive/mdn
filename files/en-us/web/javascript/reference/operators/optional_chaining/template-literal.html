<p>
    <code>String.raw</code> is an exceptional case because it only allows template literals as inputs. Most functions that can take template literals can also be executed with regular function calls.
</p>
<style>
[precode]{
    margin-left:0 !important;
    padding-left:0 !important;
    border-left-width:0 !important;
}
</style>
<div class="language-js highlighter-rouge">
    <div class="highlight">
    <pre class="highlight" precode>
<code precode>arr?.join``; // invalid syntax
arr?.join(''); // valid syntax</code></pre>
</div>
</div>
<p>This comes in quite handy for methods that potentiallly return <code>undefined</code> like <code>String.prototype.match</code>.
<div class="language-js highlighter-rouge">
    <div class="highlight">
    <pre class="highlight" precode>
<code precode>const str = 'Hello world!';

// Using match and join with optional chaining
const result = str.match(/./)?.join('');
console.log(result); // "Hello world!"

// If the regular expression doesn't match anything:
const noMatch = str.match(/z+/)?.join('');
console.log(noMatch); // undefined</code></pre>
</div>
</div>
<p>Before optional chaining we had to write code like this.</p>
<div class="language-js highlighter-rouge">
    <div class="highlight">
    <pre class="highlight" precode>
<code precode>const str = 'Hello world!';

// Old way: Fallback to empty array if no match
const oldResult = (str.match(/./)||[]).join('');
console.log(oldResult); // "Hello world!"

// If no match is found:
const oldNoMatch = (str.match(/z+/)||[]).join('');
console.log(oldNoMatch); // ""</code></pre>
</div>
</div>
