<style>
[precode]{
    margin-left:0 !important;
    padding-left:0 !important;
    border-left-width:0 !important;
}
</style>
<h3>Fetch Wrapper for Concurrent Requests</h3>
<p>
    To fetch sources concurrently, it can be convenient to have a wrapper that waits for the full response.
</p>
<div class="language-js highlighter-rouge">
<div class="highlight">
<pre class="highlight" precode>
<code precode>async function fetchText(){
  return await (await fetch(...arguments)).text();
}

const resources = await Promise.all([
  fetchText("https://example.com/1"),
  fetchText("https://example.com/2"),
  fetchText("https://example.com/3")
]);</code></pre>
</div>
</div>
<p>
	By wrapping the <code>fetch()</code> call inside a function <code>fetchText</code>, you make it reusable and concise. The function resolves with the text of the response directly, simplifying the syntax for handling multiple responses.
	This is a common pattern when you need to fetch multiple resources concurrently. By passing an array of promises to <code>Promise.all()</code>, all the requests are fired off at once, and the function only proceeds when all promises resolve.
</p>

<h3>Two Approaches to Handling Errors with Fetch</h3>
<p>Consistently managing fetch errors typically takes choosing one of two strategies. Converting runtime errors into http errors or throwing on http errors.</p>

<h4>Strategy 1: Converting Runtime Errors to HTTP Responses</h4>

<div class="language-js highlighter-rouge">
<div class="highlight">
<pre class="highlight" precode>
<code precode>async function tryFetchCatch(){
    try {
        return await fetch(...arguments);
    } catch(e) {
        return new Response(null, {status: 500, statusText: e.message});
    }
}</code></pre>
</div>
</div>

<p>
	Returning a Response on error (Strategy 1) is useful when you want to catch runtime errors and handle them like HTTP errors. This keeps your error handling uniform and makes it easier to deal with errors in the same way, regardless of their origin (HTTP status or network issue).
</p>

<h4>Strategy 2: Throwing on HTTP Errors</h4>

<div class="language-js highlighter-rouge">
<div class="highlight">
<pre class="highlight" precode>
<code precode>async function fetchThrow(){
   const res = await fetch(...arguments);
   if(!res.ok) throw new Error(res.statusText);
   return res;
}</code></pre>
</div>
</div>

<p>
	Throwing on HTTP errors (Strategy 2) is often useful when you want to ensure that only successful requests (i.e., HTTP status 200â€“299) are processed. Any other response is treated as an error and thrown, forcing the calling code to handle it.
</p>
<p>
	Many developers end up writing error handling logic twice (once for HTTP errors and again for network/runtime errors). With these strategies, you can centralize error handling, making it easier to ensure all errors are properly dealt with. Both strategies make code more concise and prevent repetitive if (res.ok) checks or catch blocks scattered throughout the application.
</p>
