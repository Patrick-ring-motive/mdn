<h3>Modifying a text body</h3>
<p>If you know that the reslonse contains text, you can read it using the <code>.text()</code> method.
reading the response body using any of the methods available, will consume the <code>ReadableStream</code> and you won't be able to access the body in the same way again.
Be sure to store the text into a variable if you need it later.
</p>
<div class="language-js highlighter-rouge">
    <div class="highlight">
    <pre class="highlight" precode>
<code precode>let response = await fetch('https://example.com');
if(/text|html|script|xml|json/i.test(response.headers.get('Content-Type')){
  let responseText = await response.text(); // This consumes the body and it cannont be read again.
  responseText = [...responseText].reverse().join``; // This reverses the text
  response = new Response(responseText,response); // Use the modified text body to create a new response object.
}</code></pre>
</div>
</div>
<p>This process automatically decodes and then encodes back the body using utf-8. If you need to use a different encoding then resolve using <code>arrarBuffer()</code> and use a TextDecoder and TextEncoder. Here is an example how you might use encoders if you are not sure if your response is text or not.</p>
<div class="language-js highlighter-rouge">
    <div class="highlight">
    <pre class="highlight" precode>
<code precode>let response = await fetch('https://example.com');
let responseArrayBuffer = await response.arrayBuffer(); // This consumes the body and it cannont be read again.
try{
  let responseText = new TextDecoder().decode(arrayBuffer); //convert the body bytes to text
  responsText = [...responseText].reverse().join``; // This reverses the text
  responseArrayBuffer = new TextEncoder().encode(responseText); //convert the text back to bytes
}catch(e){
  console.log(e); // if there is an encoding problem then an error will be logged
}
response = new Response(responseText,response); // Use the modified text body to create a new response object.</code></pre>
</div>
</div>